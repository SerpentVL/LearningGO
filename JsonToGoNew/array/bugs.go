package array

// Это - база переводов для типа сообщения.
// см. также ../trace_translator/messages.go - там переводятся сами сообщения.
// но если сообщение совпадает с типом, то переводы сообщения берутся из этой базы bugs

var bugs = []Bug{
	// Номер CWE не точный, не знаю к чему именно эти два бага отнести, возможно что-то из 1210
	{"0.0", "Analyzer Statistics", "", "Internal Statistics", 699, "Статистика анализатора"}, // AnalyzerStatsChecker.cpp:114
	{"0.0", "Sink Point", "", "Internal Statistics", 699, "Точка стока"},                     // AnalyzerStatsChecker.cpp:132

	{"0.7", "Out-of-bound array access", "", "Logic Error", 788, "Выход за пределы массива"},                                                                                                                     // ArrayBoundChecker.cpp:69 + CStringChecker.cpp:677
	{"0.7", "Out-of-bound access", "", "Logic Error", 788, "Выход за пределы памяти"},                                                                                                                            // ArrayBoundCheckerV2.cpp:239
	{"0.0", "nil argument", "", "API Misuse (Apple)", 687, "нулевой аргумент"},                                                                                                                                   // BasicObjCFoundationChecks.cpp:214
	{"0.0", "Bad use of CFNumber APIs", "", "API Misuse (Apple)", 1228, "Плохое использование CFNumber APIs"},                                                                                                    // BasicObjCFoundationChecks.cpp:520
	{"0.0", "null passed to CF memory management function", "", "API Misuse (Apple)", 1006, "ноль передан в функцию управления памятью CF"},                                                                      // BasicObjCFoundationChecks.cpp:534
	{"0.0", "message incorrectly sent to class instead of class instance", "", "API Misuse (Apple)", 1006, "сообщение ошибочно отправлено классу, а не экземпляру"},                                              // BasicObjCFoundationChecks.cpp:610
	{"0.0", "Arguments passed to variadic method aren't all Objective-C pointer types", "", "API Misuse (Apple)", 1006, "Не все аргументы переданные в вариативный метод являются указателями типа Objective-C"}, // BasicObjCFoundationChecks.cpp:717
	{"0.7", "Call to blocking function in critical section", "", "Blocking Error", 557, "Вызов блокирующей функции в критической секции"},                                                                        // BlockInCriticalSectionChecker.cpp:78
	{"0.3", "Assignment of a non-Boolean value", "", "Logic Error", 681, "Присвоение не-булевого значения"},                                                                                                      // BoolAssignmentChecker.cpp:40

	// В clang в файле clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp возможно ошибка,
	// и названия категорий багов присваиваются именам багов
	// в комментариях находятся предполагаемые правильные версии багов
	// и их категорий
	{"0.0", "Improper arguments", "", "Unix API", 628, "Неправильные аргументы"},                                                   // CStringChecker.cpp:623
	{"0.0", "Unix API", "", "Logic Error", 1006, "Unix API"},                                                                       // CStringChecker.cpp:639 + 699
	{"0.0", "Accessing unitialized/garbage values", "", "Logic Error", 908, "Обращение к неинициализированным/мусорным значениям"}, // CStringChecker.cpp:660
	{"0.5", "API", "", "Logic Error", 1006, "API"},                                                                                 // CStringChecker.cpp:716
	//	{"0.7", "Null pointer argument in call to byte string function", "", "Unix API", 688, "Нулевой указатель как аргумент при вызове функции"},	// CStringChecker.cpp:639
	//	{"0.4", "Argument is not a null-terminated string.", "", "Unix API", 686, "Аргумент не является нуль-терминированной строкой"},				// CStringChecker.cpp:699
	//	{"0.5", "Sum of expressions causes overflow.", "", "API", 190, "Сумма выражений вызывает переполнение"},									// CStringChecker.cpp:716

	{"0.3", "Anti-pattern in the argument", "", "C String API", 398, "Анти-паттерн в аргументе"},                                                                                                       // CStringSyntaxChecker.cpp:238 + 262
	{"0.0", "Uninitialized argument value", "", "Logic Error", 687, "Неинициализированное значение аргумента"},                                                                                         // CallAndMessageChecker.cpp:47 + 40
	{"0.7", "Called function pointer is an uninitialized pointer value", "", "Logic Error", 824, "Попытка вызова по неинициализированному указателю на функцию"},                                       // CallAndMessageChecker.cpp:382
	{"0.8", "Called function pointer is null (null dereference)", "", "Logic Error", 476, "Попытка вызова по нулевому указателю на функцию (разыменование нулевого указателя)"},                        // CallAndMessageChecker.cpp:398
	{"0.0", "Function call with too few arguments", "", "Logic Error", 685, "Вызов функции с недостаточным количеством аргументов"},                                                                    // CallAndMessageChecker.cpp:425
	{"0.7", "Called C++ object pointer is uninitialized", "", "Logic Error", 824, "Попытка вызова по неинициализированному указателю на объект C++"},                                                   // CallAndMessageChecker.cpp:453
	{"0.8", "Called C++ object pointer is null", "", "Logic Error", 476, "Попытка вызова по нулевому указателю на объект C++"},                                                                         // CallAndMessageChecker.cpp:469
	{"0.5", "Uninitialized argument value", "", "Logic Error", 824, "Неинициализированное значение аргумента"},                                                                                         // CallAndMessageChecker.cpp:498
	{"0.7", "Receiver in message expression is an uninitialized value", "", "Logic Error", 824, "В выражении, описывающем сообщение, получатель не инициализирован"},                                   // CallAndMessageChecker.cpp:588
	{"0.7", "Property access on an uninitialized object pointer", "", "Logic Error", 824, "Доступ к свойству объекта через неинициализированный указатель на объект"},                                  // CallAndMessageChecker.cpp:595
	{"0.7", "Subscript access on an uninitialized object pointer", "", "Logic Error", 824, "Доступ по смещению через неинициализированный указатель на объект"},                                        // CallAndMessageChecker.cpp:602
	{"0.5", "Receiver in message expression is 'nil'", "", "Logic Error", 465, "В выражении, описывающем сообщение, получатель -- 'nil'"},                                                              // CallAndMessageChecker.cpp:637
	{"0.5", "Cast region with wrong size.", "", "Logic Error", 704, "Приведение типа региона к типу неподходящего размера"},                                                                            // CastSizeChecker.cpp:135
	{"0.5", "Cast from non-struct type to struct type", "", "Logic error", 704, "Преобразование типа из неструктурного в структурный"},                                                                 // CastToStrictChecker.cpp:65
	{"0.5", "Widening cast to struct type", "", "Logic error", 704, "Попытка преобразовать структурный тип в супертип"},                                                                                // CastToStrictChecker.cpp:97
	{"0.7", "Missing -dealloc", "", "Core Foundation/Objective-C", 399, "Отсутствует -dealloc"},                                                                                                        // CheckObjCDealloc.cpp:245
	{"0.7", "Missing ivar release (leak)", "", "Memory (Core Foundation/Objective-C/OSObject)", 401, "Отсутствует освобождение ivar (утечка)"},                                                         // CheckObjCDealloc.cpp:757
	{"0.7", "Extra ivar release", "", "Memory (Core Foundation/Objective-C/OSObject)", 1341, "Лишнее освобождение ivar"},                                                                               // CheckObjCDealloc.cpp:761
	{"0.5", "Mistaken dealloc", "", "Memory (Core Foundation/Objective-C/OSObject)", 399, "Ошибочный вызов dealloc"},                                                                                   // CheckObjCDealloc.cpp:765
	{"0.6", "Incompatible instance method return type", "", "Core Foundation/Objective-C", 389, "Несовместимый тип возвращаемого значения в методе экземпляра"},                                        // CheckObjCInstMethSignature.cpp:70
	{"0.0", "Insufficient storage for placement new", "", "Memory error", 1202, "Недостаточно места для placement new"},                                                                                // CheckPlacementNew.cpp:57
	{"0.0", "Bad align storage for placement new", "", "Memory error", 1202, "Плохое выравнивание хранилища для placement new"},                                                                        // CheckPlacementNew.cpp:59
	{"0.3", "Floating point variable used as loop counter", "", "Security", 254, "Переменная с плавающей запятой используется как счетчик цикла"},                                                      // CheckSecuritySyntaxOnly.cpp:338
	{"0.2", "Use of deprecated function in call to 'bcmp()'", "", "Security", 477, "Использование устаревшей функции при вызове 'bcmp()'"},                                                             // CheckSecuritySyntaxOnly.cpp:378
	{"0.2", "Use of deprecated function in call to 'bcopy()'", "", "Security", 477, "Использование устаревшей функции при вызове 'bcopy()'"},                                                           // CheckSecuritySyntaxOnly.cpp:420
	{"0.2", "Use of deprecated function in call to 'bzero()'", "", "Security", 477, "Использование устаревшей функции при вызове 'bzero()'"},                                                           // CheckSecuritySyntaxOnly.cpp:461
	{"0.3", "Potential buffer overflow in call to 'gets'", "", "Security", 242, "Потенциальное переполнение буфера при вызове 'gets'"},                                                                 // CheckSecuritySyntaxOnly.cpp:499
	{"0.3", "Potential buffer overflow in call to 'getpw'", "", "Security", 477, "Потенциальное переполнение буфера при вызове 'getpw'"},                                                               // CheckSecuritySyntaxOnly.cpp:539
	{"0.7", "Potential insecure temporary file in call 'mktemp'", "", "Security", 377, "Потенциально небезопасный временный файл в вызове 'mktemp'"},                                                   // CheckSecuritySyntaxOnly.cpp:580
	{"0.7", "Insecure temporary file creation", "", "Security", 378, "Небезопасное создание временного файла"},                                                                                         // CheckSecuritySyntaxOnly.cpp:666
	{"1.0", "Potential insecure memory buffer bounds restriction in call 'strcpy'", "", "Security", 119, "Потенциально небезопасное задание границ буфера при вызове 'strcpy'"},                        // CheckSecuritySyntaxOnly.cpp:699
	{"1.0", "Potential insecure memory buffer bounds restriction in call 'strcat'", "", "Security", 119, "Потенциально небезопасное задание границ буфера при вызове 'strcat'"},                        // CheckSecuritySyntaxOnly.cpp:727
	{"0.0", "Potential insecure memory buffer bounds restriction in call '", "'", "Security", 1218, "Потенциально небезопасное ограничение границ буфера памяти при вызове "},                          // CheckSecuritySyntaxOnly.cpp:814
	{"0.0", "'", "' is a poor random number generator", "Security", 338, " является плохим генератором случайных чисел"},                                                                               // CheckSecuritySyntaxOnly.cpp:888 TODO: \ написан в одинарных кавычках, надо тестить
	{"0.7", "'random' is not a secure random number generator", "", "Security", 338, "'random' не является безопасным генератором случайных чисел"},                                                    // CheckSecuritySyntaxOnly.cpp:913
	{"0.7", "Potential insecure implementation-specific behavior in call 'vfork'", "", "Security", 242, "Потенциально небезопасное поведение, определяемое реализацией, в вызове 'vfork'"},             // CheckSecuritySyntaxOnly.cpp:933
	{"0.0", "Potential buffer overflow in '-decodeValueOfObjCType:at:'", "", "Security", 1218, "Потенциальное переполнение буфера в '-decodeValueOfObjCType:at:'"},                                     // CheckSecuritySyntaxOnly.cpp:983
	{"0.0", "Return value is not checked in call to '", "", "Security", 252, "Возвращаемое значение не проверяется в функции вызова"},                                                                  // CheckSecuritySyntaxOnly.cpp:1052
	{"0.5", "Potential unintended use of sizeof() on pointer type", "", "Logic error", 467, "Возможно непреднамеренное применение sizeof() к указателю"},                                               // CheckSizeofPointer.cpp:66
	{"0.8", "Break out of jail", "", "Logic Error", 243, "Выход за пределы jail"},                                                                                                                      // ChrootChecker.cpp:128
	{"0.3", "Exact code clone", "", "Code clone", 1041, "Точная копия кода"},                                                                                                                           // CloneChecker.cpp:112
	{"0.3", "Suspicious code clone", "", "Code clone", 1041, "Подозрительная копия кода"},                                                                                                              // CloneChecker.cpp:158
	{"0.3", "Conversion", "", "Logic Error", 681, "Преобразование. Возможная потеря знака/точности"},                                                                                                   // ConversionChecker.cpp:130
	{"0.3", "Dead initialization", "", "Unused code", 563, "Неиспользуемая инициализация"},                                                                                                             // DeadStoresChecker.cpp:218
	{"0.3", "Dead increment", "", "Unused code", 563, "Неиспользуемый инкремент"},                                                                                                                      // DeadStoresChecker.cpp:242
	{"0.3", "Dead assignment", "", "Unused code", 563, "Неиспользуемое присваивание"},                                                                                                                  // DeadStoresChecker.cpp:245
	{"0.3", "Dead nested assignment", "", "Unused code", 563, "Неиспользуемое вложенное присваивание"},                                                                                                 // DeadStoresChecker.cpp:253
	{"0.0", "Checking analyzer assumptions", "", "debug", 1207, "Проверка предположений анализатора"},                                                                                                  // DebugContainerModeling.cpp:60 + DebugIteratorModeling.cpp:63 + ExprInspectionChecker.cpp:181
	{"0.5", "Destruction of a polymorphic object with no virtual destructor", "", "Logic error", 1079, "Попытка деструкции полиморфного объекта, не имеющего виртуального деструктора"},                // DeleteWithNonVirtualDtorChecker.cpp:89
	{"0.0", "Dereference of null pointer", "", "Logic Error", 476, "Разыменование нулевого указателя"},                                                                                                 // DereferenceChecker.cpp:161 + NonNullParamChecker.cpp:306
	{"0.0", "Dereference of undefined pointer value", "", "Logic Error", 824, "Разыменование указателя с неопределенным значением"},                                                                    // DereferenceChecker.cpp:166
	{"0.3", "Property access", "", "Core Foundation/Objective-C", 1006, "Получение доступа к свойству"},                                                                                                // DirectIvarAssignment.cpp:200
	{"1.0", "Division by zero", "", "Logic Error", 369, "Деление на ноль"},                                                                                                                             // DivZeroChecker.cpp:49 + TestAfterDivZeroChecker.cpp:169
	{"0.5", "Dynamic and static type mismatch", "", "Type Error", 136, "Несоответствие динамического и статического типов"},                                                                            // DynamicTypeChecker.cpp:36
	{"0.5", "Generics", "", "Core Foundation/Objective-C", 704, "Дженерики"},                                                                                                                           // DynamicTypePropagation:71
	{"0.5", "Enum cast out of range", "", "Logic Error", 704, "Приводимое значение выходит за пределы перечисляемого типа"},                                                                            // EnumCastOutOfRangeChecker.cpp:84
	{"0.0", "Value of 'errno' was not checked", "", "Error handling", 1006, "Значение 'errno' не проверяется"},                                                                                         // ErrnoChecker.cpp:127
	{"0.0", "Value of 'errno' could be undefined", "", "Error handling", 1006, "Значение 'errno' может быть неопределенным"},                                                                           // ErrnoChecker.cpp:153
	{"0.1", "Use fixed address", "", "Logic Error", 587, "Использование фиксированного адреса"},                                                                                                        // FixedAddressChecker.cpp:54
	{"0.0", "Fuchsia handle leak", "", "Fuchsia Handle Error", 772, "Утечка памяти обработчика Fuchsia"},                                                                                               // FuchsiaHandleChecker.cpp:190
	{"0.0", "Fuchsia handle double release", "", "Fuchsia Handle Error", 1341, "Двойное освобождение памяти обработчика Fuchsia"},                                                                      // FuchsiaHandleChecker.cpp:192
	{"0.0", "Fuchsia handle release of unowned handle", "", "Fuchsia Handle Error", 399, "Освобождение обработчика Fuchsia бесхозным обработчиком"},                                                    // FuchsiaHandleChecker.cpp:194
	{"0.0", "Fuchsia handle use after release", "", "Fuchsia Handle Error", 399, "Использование обработчика Fuchsia после освобождения памяти"},                                                        // FuchsiaHandleChecker.cpp:197
	{"0.2", "GCD performance anti-pattern", "", "Performance", 398, "Анти-паттерн производительности GCD"},                                                                                             // GCDAntipatternChecker.cpp:193
	{"0.5", "Use of Untrusted Data", "", "Untrusted Data", 502, "Использование ненадежных данных"},                                                                                                     // GenericTaintChecker.cpp:346
	{"0.3", "Use of identical expressions", "", "Logic error", 1041, "Использование идентичных выражений"},                                                                                             // IdenticalExprChecker.cpp:71
	{"0.3", "Identical conditions", "", "Logic error", 1041, "Идентичные условия"},                                                                                                                     // IdenticalExprChecker.cpp:143 + 120
	{"0.3", "Identical branches", "", "Logic error", 1041, "Идентичные ветки"},                                                                                                                         // IdenticalExprChecker.cpp:173
	{"0.2", "Compare of identical expressions", "", "Logic error", 569, "Сравнение идентичных выражений"},                                                                                              // IdenticalExprChecker.cpp:264
	{"0.2", "Identical expressions in conditional expression", "", "Logic error", 569, "Идентичные выражения в условии"},                                                                               // IdenticalExprChecker.cpp:285
	{"0.5", "Iterator invalidated", "", "Misuse of STL APIs", 825, "Итератор инвалидирован"},                                                                                                           // InvalidatedIteratorChecker.cpp:53
	{"0.5", "Iterator out of range", "", "Misuse of STL APIs", 465, "Итератор вышел за пределы"},                                                                                                       // IteratorRangeChecker.cpp:75
	{"0.7", "Incomplete invalidation", "", "Core Foundation/Objective-C", 459, "Неполная инвалидация"},                                                                                                 // IvarInvalidationChecker.cpp:545, 563, 568
	{"0.0", "StringRef should not be bound to temporary std::string that it outlives", "", "LLVM Conventions", 1006, "StringRef не должен быть привязан к временному std::string, живет меньше"},       // LLVMConventionsChecker.cpp:183
	{"0.5", "AST node allocates heap memory", "", "LLVM Conventions", 399, "Узел AST выделяет память в куче"},                                                                                          // LLVMConventionsChecker.cpp:287
	{"0.2", "Unlocalizable string", "", "Localizability Issue (Apple)", 398, "Непереводимая строка"},                                                                                                   // LocalizationChecker.cpp:111
	{"0.2", "Context Missing", "", "Localizability Issue (Apple)", 398, "Отсутствует контекст"},                                                                                                        // LocalizationChecker.cpp:1189
	{"0.2", "Plural Misuse", "", "Localizability Issue (Apple)", 398, "Неверное использование множественного числа"},                                                                                   // LocalizationChecker.cpp:1390
	{"0.0", "Use-after-free (MIG calling convention violation)", "", "Memory error", 399, "Использование после освобождения памяти (нарушение согласования о вызовах MIG)"},                            // MIGChecker.cpp:41
	{"0.7", "Improper use of SecKeychain API", "", "API Misuse (Apple)", 399, "Неправильное использование API SecKeychain"},                                                                            // MacOSKeychainAPIChecker.cpp:105
	{"0.3", "Improper use of 'dispatch_once'", "", "API Misuse (Apple)", 1006, "Неправильное использование 'dispatch_once'"},                                                                           // MacOSXAPIChecker.cpp:140
	{"0.7", "Bad free", "", "Memory error", 763, "Плохой вызов free"},                                                                                                                                  // MallocChecker.cpp:2217 + 2536
	{"0.2", "Free alloca()", "", "Memory error", 590, "Попытка освободить при помощи free блок, созданный при помощи alloca()"},                                                                        // MallocChecker.cpp:2265
	{"0.7", "Bad deallocator", "", "Memory error", 763, "Плохой деаллокатор"},                                                                                                                          // MallocChecker.cpp:2290
	{"0.7", "Offset free", "", "Memory error", 761, "Вызов free с неправильным адресом блока памяти"},                                                                                                  // MallocChecker.cpp:2353
	{"0.7", "Use-after-free", "", "Memory error", 416, "Использование после освобождения"},                                                                                                             // MallocChecker.cpp:2407
	{"0.7", "Double free", "", "Memory error", 415, "Двойной вызов free"},                                                                                                                              // MallocChecker.cpp:2446
	{"0.2", "Double delete", "", "Memory error", 415, "Двойной вызов delete"},                                                                                                                          // MallocChecker.cpp:2476
	{"0.5", "Use of zero allocated", "", "Memory error", 399, "Попытка выделить блок памяти нулевого размера"},                                                                                         // MallocChecker.cpp:2504
	{"0.7", "Memory leak", "", "Memory error", 401, "Утечка памяти"},                                                                                                                                   // MallocChecker.cpp:2754
	{"0.7", "malloc() size overflow", "", "Unix API", 789, "Переполнение размера при вызове malloc"},                                                                                                   // MallocOverflowSecurityChecker.cpp:288
	{"0.5", "Allocator sizeof operand mismatch", "", "Unix API", 131, "Аргумент sizeof не совпадает с типом указателя на выделяемую память"},                                                           // MallocSizeofChecker.cpp:244
	{"0.0", "Iterator(s) mismatched", "", "Misuse of STL APIs", 1006, "Несовпадение итераторов"},                                                                                                       // MismatchedIteratorChecker.cpp:58
	{"0.8", "W^X check fails, Write Exec prot flags set", "", "Security", 200, "Проверка W^X не пройдена, установлены оба флага - Write и Exec"},                                                       // MmapWriteExecChecker.cpp:64
	{"0.5", "Use-after-move", "", "C++ move semantics", 399, "Попытка использования объекта после того, как он был перемещен (use-after-move)"},                                                        // MoveChecker.cpp:204
	{"0.3", "Use -drain instead of -release", "", "API Upgrade (Apple)", 1006, "Используйте -drain вместо -release"},                                                                                   // NSAutoreleasePoolChecker.cpp:61
	{"0.3", "Bad return type when passing NSError**", "", "Coding conventions (Apple)", 1006, "Плохой тип возвращаемого значения при передаче NSError**"},                                              // NSErrorChecker.cpp:77
	{"0.3", "Bad return type when passing CFErrorRef*", "", "Coding conventions (Apple)", 1006, "Плохой тип возвращаемого значения при передаче CFErrorRef*"},                                          // NSErrorChecker.cpp:135
	{"0.8", "NSError** null dereference", "", "Coding conventions (Apple)", 476, "Попытка разыменования нулевого указателя NSError**"},                                                                 // NSErrorChecker.cpp:149
	{"0.8", "CFErrorRef* null dereference", "", "Coding conventions (Apple)", 476, "Попытка разыменования нулевого указателя CFErrorRef*"},                                                             // NSErrorChecker.cpp:156
	{"0.7", "Argument with 'nonnull' attribute passed null", "", "API", 476, "Аргумент с атрибутом 'nonnull' равен нулевому указателю"},                                                                // NonNullParamChecker.cpp:285
	{"0.8", "Dereference of null pointer", "", "Logic Error", 476, "Разыменование нулевого указателя"},                                                                                                 // NonNullParamChecker.cpp:306 + StringChecker.cpp:26
	{"0.6", "Nullability", "", "Memory error", 476, "Возможность обнуления"},                                                                                                                           // NullabilityChecker.cpp:126
	{"0.4", "Suspicious number object conversion", "", "Logic error", 682, "Подозрительное преобразование числового объекта"},                                                                          // NumberObjectConversionChecker.cpp:188
	{"0.5", "OSObject C-Style Cast", "", "Security error", 704, "Приведение типа OSObject в C-стиле"},                                                                                                  // OSObjectCStyleCast.cpp:66
	{"0.7", "Uninitialized value used as mutex for @synchronized", "", "Logic Error", 662, "Неинициализированное значение используется как мьютекс для @synchronized"},                                 // ObjCAtSyncChecker.cpp:47
	{"0.7", "Nil value used as mutex for @synchronized() (no synchronization will occur)", "", "Logic Error", 662, "Значение nil используется как мьютекс для @synchronized (синхронизации не будет)"}, // ObjCAtSyncChecker.cpp:70
	// В первом параметре имени будет написано либо "Write to", либо "Capture of", т.е. "Запись ..." или "Захват ..."
	{"0.0", "", " autoreleasing out parameter inside autorelease pool", "Memory (Core Foundation/Objective-C/OSObject)", 399, " параметра автоосвобождения внутри пула автоосвобождения"},     // ObjCAutoreleaseWriteChecker.cpp:165
	{"0.0", " Invalid use of '", "'", "Core Foundation/Objective-C", 1006, "Неправильное использование "},                                                                                     // ObjCContainersASTChecker.cpp:144
	{"0.5", "CFArray API", "", "Core Foundation/Objective-C", 465, "CFArray API"},                                                                                                             // ObjCContainersChecker.cpp:36
	{"0.0", "Missing call to superclass", "", "Core Foundation/Objective-C", 1006, "Отсутствует вызов суперкласса"},                                                                           // ObjCMissingSuperCallChecker.cpp:209
	{"0.3", "Objective-C property misuse", "", "Logic error", 1006, "Неправильное использование свойства в Objective-C"},                                                                      // ObjCPropertyChecker.cpp:72
	{"0.0", "Missing \"self = [(super or self) init...]\"", "", "Core Foundation/Objective-C", 909, "Отсутствует инициализация своего или родительского класса"},                              // ObjCSelfInitChecker.cpp:161
	{"0.5", "[super dealloc] should not be called more than once", "", "Core Foundation/Objective-C", 399, "[super dealloc] не должен вызываться более одного раза"},                          // ObjCSuperDeallocChecker.cpp:219
	{"0.1", "Unused instance variable", "", "Optimization", 1164, "Неиспользованная переменная в экземпляре"},                                                                                 // ObjCUnusedIVarsChecker.cpp:165
	{"0.0", "Excessive Padding", "", "Performance", 1006, "Чрезмерное заполнение"},                                                                                                            // PaddingChecker.cpp:315
	{"0.6", "Dangerous pointer arithmetic", "", "Logic Error", 188, "Небезопасная арифметика указателей"},                                                                                     // PointerArithChecker.cpp:173, 195
	{"0.5", "Iteration of pointer-like elements", "", "Non-determinism", 465, "Итерирование указателеподобных элементов"},                                                                     // PointerIterationChecker.cpp:52
	{"0.5", "Sorting of pointer-like elements", "", "Non-determinism", 465, "Сортировка указателеподобных элементов"},                                                                         // PointerSortingChecker.cpp:52
	{"0.9", "Pointer subtraction", "", "Logic Error", 469, "Вычитание указателей"},                                                                                                            // PointerSubChecker.cpp:63
	{"0.7", "Double locking", "", "Lock checker", 667, "Двойная блокировка"},                                                                                                                  // PthreadLockChecker.cpp:236
	{"0.7", "Double unlocking", "", "Lock checker", 667, "Двойная разблокировка"},                                                                                                             // PthreadLockChecker.cpp:238
	{"0.7", "Use destroyed lock", "", "Lock checker", 667, "Использование уничтоженного мьютекса"},                                                                                            // PthreadLockChecker.cpp:240
	{"0.7", "Init invalid lock", "", "Lock checker", 667, "Инициализация невалидного мьютекса"},                                                                                               // PthreadLockChecker.cpp:242
	{"0.7", "Lock order reversal", "", "Lock checker", 667, "Нарушение порядка блокировки"},                                                                                                   // PthreadLockChecker.cpp:244
	{"0.7", "Destroy invalid lock", "", "Lock checker", 667, "Уничтожение невалидного мьютекса"},                                                                                              // PthreadLockChecker.cpp:397(clang.10x)  REMOVED
	{"0.7", "Buffer overflow", "", "Logic Error", 466, "Переполнение буфера"},                                                                                                                 // ReturnPointerRangeChecker.cpp:82
	{"0.5", "Garbage return value", "", "Logic Error", 465, "Возвращаемое значение содержит мусор"},                                                                                           // ReturnUndefChecker.cpp:98
	{"0.5", "Returning null reference", "", "Logic Error", 465, "Возвращается нулевая ссылка"},                                                                                                // ReturnUndefChecker.cpp:116
	{"0.7", "Memory leak inside autorelease pool", "", "Memory", 399, "Утечка памяти в пуле автоматического освобождения"},                                                                    // RunLoopAutoreleaseLeakChecker.cpp:116
	{"0.0", "Double fclose", "", "Unix Stream API Error", 399, "Двойной вызов fclose"},                                                                                                        // SimpleStreamChecker.cpp:95
	{"0.0", "Resource Leak", "", "Unix Stream API Error", 772, "Утечка ресурса"},                                                                                                              // SimpleStreamChecker.cpp:99
	{"0.0", "Null SmartPtr dereference", "", "C++ Smart Pointer", 476, "Разыменование нулевого SmartPtr"},                                                                                     // SmartPtrChecker.cpp:38
	{"0.0", "Return of address to stack-allocated memory", "", "Logic Error", 562, "Возврат адреса в память, выделенную стеком"},                                                              // StackAddrEscapeChecker.cpp:151
	{"0.0", "Address of stack-allocated memory is captured", "", "Logic Error", 1006, "Захвачен адрес выделенной в стеке памяти"},                                                             // StackAddrEscapeChecker.cpp:191 + 217
	{"0.0", "Stack address stored into global variable", "", "Logic Error", 1006, "Адрес стека хранится в глобальной переменной"},                                                             // StackAddrEscapeChecker.cpp:361
	{"0.0", "Unsatisfied argument constraints", "", "Logic Error", 1006, "Неудовлетворительные ограничения аргумента"},                                                                        // StdLibraryFunctionsChecker.cpp:737
	{"0.0", "Closed stream", "", "Stream handling error", 1341, "Поток может быть уже закрыт. Возможно неопределенное поведение."},                                                            // StreamChecker.cpp:213
	{"0.0", "Invalid stream", "", "Stream handling error", 399, "Поток может быть в невалидном состоянии после ошибки открытия. Может привести к неопределенному поведению."},                 // StreamChecker.cpp:214
	{"0.0", "Invalid stream state", "", "Stream handling error", 399, "Позиция файла потока может быть неопределенной после неудачной операции. Может привести к неопределенному поведению."}, // StreamChecker.cpp:216
	{"0.0", "Illegal whence argument", "", "Stream handling error", 1006, "Аргумент whence в fseek() должен быть SEEK_SET, SEEK_END, или SEEK_CUR."},                                          // StreamChecker.cpp:218
	{"0.0", "Stream already in EOF", "", "Stream handling error", 399, "Функция чтения вызывается когда поток находится в состоянии EOF. Функция ничего не делает."},                          // StreamChecker.cpp:220
	{"0.0", "Resource leak", "", "Stream handling error", 772, "Открытый поток никогда не закрывается. Потенциальная утечка данных."},                                                         // StreamChecker.cpp:221
	{"0.8", "NULL stream pointer", "", "Logic Error", 476, "Указатель на поток равен NULL"},                                                                                                   //	REMOVED																							// StreamChecker.cpp:255
	{"0.5", "Tainted data", "", "General", 19, "Помеченные данные"},                                                                                                                           // TaintTesterChecker.cpp:26
	{"0.5", "Branch condition evaluates to a garbage value", "", "Logic Error", 465, "Мусорное значение в условии ветвления"},                                                                 // UndefBranchChecker.cpp:74
	{"0.7", "uninitialized variable captured by block", "", "Logic Error", 824, "Блок захватил неинициализированную переменную"},                                                              // UndefCapturedBlockVarChecker.cpp:77
	{"0.5", "Result of operation is garbage or undefined", "", "Logic Error", 465, "Результат операции не определён или содержит мусор"},                                                      // UndefResultChecker.cpp:94
	{"0.7", "Array subscript is undefined", "", "Logic Error", 824, "Индекс массива не определен"},                                                                                            // UndefinedArraySubscriptChecker.cpp:52
	{"0.5", "Assigned value is garbage or undefined", "", "Logic Error", 465, "Присвоенное значение содержит мусор или неопределено"},                                                         // UndefinedAssignmentChecker:56
	{"0.0", "Undefined array element count in new[]", "", "Logic Error", 399, "Неопределенное количество элементов массива в new[]"},                                                          // UndefinedNewArraySizeChecker.cpp:28
	{"0.0", "Improper use of 'open'", "", "Unix API", 1228, "Неуместное использование 'open'"},                                                                                                // UnixAPIChecker.cpp:135
	{"0.0", "Improper use of 'pthread_once'", "", "Unix API", 1228, "Неуместное использование 'pthread_once'"},                                                                                // UnixAPIChecker.cpp:304
	{"0.0", "Undefined allocation of 0 bytes (CERT MEM04-C; CWE-131)", "", "Unix API", 131, "Неопределенное выделение 0 байтов"},                                                              // UnixAPIChecker.cpp:344
	{"0.0", "Unreachable code", "", "Unused code", 561, "Недостижимый код"},                                                                                                                   // UnreachableCodeChecker.cpp:173
	{"0.5", "Dangerous variable-length array (VLA) declaration", "", "Logic Error", 789, "Небезопасное объявление массива переменной длины (VLA)"},                                            // VLASizeChecker.cpp:221
	{"0.7", "Uninitialized va_list", "", "Memory error", 824, "Неинициализированный va_list"},                                                                                                 // ValistChecker.cpp:255
	{"0.7", "Leaked va_list", "", "Memory error", 401, "Утечка va_list"},                                                                                                                      // ValistChecker.cpp:276
	{"0.7", "Dangerous construct in a vforked process", "", "Logic Error", 399, "Небезопасная конструкция в процессе, вызванном vfork()"},                                                     // VforkChecker.cpp:127
	{"0.0", "Pure virtual method call", "", "C++ object lifecycle", 1006, "Вызов чистого виртуального метода"},                                                                                // VirtualCallChecker.cpp:210
	{"0.0", "Unexpected loss of virtual dispatch", "", "C++ object lifecycle", 1006, "Неожиданная потеря виртуальной диспетчеризации"},                                                        // VirtualCallChecker.cpp:219
	{"0.4", "Uninitialized fields", "", "Logic Error", 456, "Неинициализированные переменные"},                                                                                                // UninitializedObject/UninitializedObjectChecker.cpp:48
}
